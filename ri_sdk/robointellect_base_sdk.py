"""
Autogenerated!
Do not edit manually.
"""

from __future__ import annotations

import ctypes
from typing import TYPE_CHECKING, Protocol, TypeVar, Union

from ri_sdk.exceptions import MethodCallError

if TYPE_CHECKING:
    ErrorBufferType = TypeVar("ErrorBufferType", bound=ctypes.Array[ctypes.c_char])

    class MethodProtocol(Protocol):
        def __call__(self, *args: ArgsType | ErrorBufferType) -> int:
            pass


ArgsType = Union[
    int,
    bool,
    float,
    bytes,
    ctypes.c_uint8,
    ctypes.c_int,
    ctypes.c_bool,
    ctypes.c_float,
    ctypes.c_char_p,
    ctypes.c_ulonglong,
]


class RoboIntellectBaseSDK:
    def __init__(
        self,
        lib: ctypes.CDLL,
        setup_methods_args: bool = False,
    ) -> None:
        """
        :param lib: RI SDK library .dll or .so
        :param setup_methods_args: whether to configure methods args on init
        """
        self.lib = lib
        if setup_methods_args:
            self.setup_all_methods_args_types()

    @classmethod
    def process_result(
        cls,
        error_code: int,
        error_text_c: ErrorBufferType,
        method_name: str,
    ) -> None:
        """
        :param error_code:
        :param error_text_c:
        :param method_name:
        :return: None if error code is 0. otherwise raises
        :raises: MethodCallError
        """
        if not error_code:
            return

        raise MethodCallError(
            error_code=error_code,
            error_message=error_text_c.raw,
            method_name=method_name,
        )

    def setup_all_methods_args_types(self) -> None:
        """
        Установка типов аргументов всех методов.
        :return:
        """
        for name in dir(self):
            if not name.startswith("setup_arg_types_"):
                continue
            method = getattr(self, name)
            method()

    def call_sdk_method(
        self,
        method_name: str,
        *args: ArgsType,
    ) -> int:
        """
        Вызывает метод, передавая ему все прокинутые аргументы.
        Если статус 0, возвращает этот статус.
        Если статус не 0, выкидывает исключение MethodCallError

        :param method_name: RI SDK method name
        :param args: all method args to be passed
        :return: error code
        :raises: MethodCallError
        """
        # берем метод библиотеки RI SDK
        method: MethodProtocol = getattr(self.lib, method_name)

        # error_text_c - Текст ошибки. Передается как параметр
        # если происходит ошибка, метод записывает текст в этот параметр
        error_text_c = ctypes.create_string_buffer(1000)
        # Код ошибки. Получаем по результату вызова метода
        error_code = method(*args, error_text_c)
        self.process_result(
            error_code=error_code,
            error_text_c=error_text_c,
            method_name=method_name,
        )
        return error_code
