"""
Autogenerated!
Do not edit manually.
## this is the template. it may and should be edited manually.
"""
from __future__ import annotations

import ctypes
from typing import Protocol, TypeVar, Union, TYPE_CHECKING

from ri_sdk import types, utils
from ri_sdk.exceptions import MethodCallError


if TYPE_CHECKING:
    ErrorBufferType = TypeVar("ErrorBufferType", bound=ctypes.Array[ctypes.c_char])

    class MethodProtocol(Protocol):
        def __call__(self, *args: ArgsType | ErrorBufferType) -> int:
            pass


ArgsType = Union[
    int,
    bool,
    float,
    bytes,
    ctypes.c_uint8,
    ctypes.c_int,
    ctypes.c_bool,
    ctypes.c_float,
    ctypes.c_char_p,
    ctypes.c_ulonglong,
]

<%!
from ri_sdk_codegen.rendering.render_helpers import (
    lib_ctype_param,
    function_param,
    function_param_doc,
    receiver_var_comment,
    prepare_param_for_sdk_call,
    prepare_param_for_sdk_call_result,
    method_description,
    comment_ctype_param,
)
%>

class RoboIntellectBaseSDK:
    def __init__(
        self,
        lib: ctypes.CDLL,
        setup_methods_args: bool = False,
    ) -> None:
        """
        :param lib: RI SDK library .dll or .so
        :param setup_methods_args: whether to configure methods args on init
        """
        self.lib = lib
        if setup_methods_args:
            self.setup_all_methods_args_types()

    @classmethod
    def process_result(
        cls,
        error_code: int,
        error_text_c: ErrorBufferType,
        method_name: str,
    ) -> None:
        """
        :param error_code:
        :param error_text_c:
        :param method_name:
        :return: None if error code is 0. otherwise raises
        :raises: MethodCallError
        """
        if not error_code:
            return

        raise MethodCallError(
            error_code=error_code,
            error_message=error_text_c.raw,
            method_name=method_name,
        )

    def setup_all_methods_args_types(self) -> None:
        """
        Установка типов аргументов всех методов.
        :return:
        """
        for name in dir(self):
            if not name.startswith("setup_arg_types_"):
                continue
            method = getattr(self, name)
            method()

    def call_sdk_method(
        self,
        method_name: str,
        *args: ArgsType,
    ) -> int:
        """
        Вызывает метод, передавая ему все прокинутые аргументы.
        Если статус 0, возвращает этот статус.
        Если статус не 0, выкидывает исключение MethodCallError

        :param method_name: RI SDK method name
        :param args: all method args to be passed
        :return: error code
        :raises: MethodCallError
        """
        # берем метод библиотеки RI SDK
        method: MethodProtocol = getattr(self.lib, method_name)

        # error_text_c - Текст ошибки. Передается как параметр
        # если происходит ошибка, метод записывает текст в этот параметр
        error_text_c = ctypes.create_string_buffer(1000)
        # Код ошибки. Получаем по результату вызова метода
        error_code = method(*args, error_text_c)
        self.process_result(
            error_code=error_code,
            error_text_c=error_text_c,
            method_name=method_name,
        )
        return error_code
##
## autogenerated section below
% for sdk_method in sdk_methods:

    def ${sdk_method.py_method_name}(
        self,
    % for param in sdk_method.func_call_params:
        ${function_param(param)},
    % endfor
    ) -> ${sdk_method.py_method_return_type}:
        ${'"""'}
${method_description(sdk_method)}

        ${sdk_method.url}

    % for param in sdk_method.func_call_params:
${function_param_doc(param)}
    % endfor
        :returns: Результат типа ${sdk_method.py_return_type_cls_name}
        :raises ValueError: если полученный код ошибки не ноль
        ${'"""'}
        # Инициализация получателей
        % for param in sdk_method.func_sdk_receivers:
% if loop.first:
## empty line for spacing

% endif
${receiver_var_comment(param)}
        ${param.py_name} = ctypes.${param.py_ctype}()
% if loop.last:
## empty line for spacing

% endif
        % endfor

        # Код ошибки. Вернётся 0, или будет выброшено исключение
        error_code = self.call_sdk_method(
            "${sdk_method.name}",
        % for param in sdk_method.func_sdk_call_args:
            ${comment_ctype_param(param)}
            ${prepare_param_for_sdk_call(sdk_method, param)},
        % endfor
        )
        return ${sdk_method.py_method_return_type}(
            error_code,
            % for param in sdk_method.func_sdk_receivers:
            ${prepare_param_for_sdk_call_result(sdk_method, param)},
            % endfor
        )
% endfor
% for sdk_method in sdk_methods:

    def setup_arg_types_for_${sdk_method.py_method_name}(self) -> None:
        ${'"""'}
        Инициализация метода ${sdk_method.name}

        Обращение и документация:
        >>> self.${sdk_method.py_method_name}

        ${sdk_method.url}
        ${'"""'}
        self.lib.${sdk_method.name}.argtypes = [
        % for param in sdk_method.params:
        % if param.name != 'errorCode':
            ${comment_ctype_param(param)}
            ${lib_ctype_param(param)},
        % endif
        % endfor
        ]
% endfor
